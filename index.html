<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="basic.css" type="text/css" />
    <title>Florian Hanke's View Models on Github</title>
  </head>
  <body>
    <h1>View Models</h1>
    <h2>Silly Tagline</h2>
    <p>The missing glue between the letters in ruby on rails' MVC.</p>
    <h2>But why? Let me tell you a story of high adventure</h2>
    <p>During writing a music community platform with multiple different profile types – in our case bands, normal members, venues, and labels – it occurred to us that type specific methods were hard to place. As a simple example a method that generates the displayed name.</p>
    <h2>The problem</h2>
    <p>For bands that needed to be just the band name, for members the name and surname, for labels the name along with the amount of bands under contract.</p>
    <h2>A long and arduous journey</h2>
    <p>First, we tried putting it into models, but that <em>violated the MVC principle</em>, we didn't feel to good about sticking view code into the model. Besides, all view helpers were pretty inaccessible.</p>
    <p>Even after sticking the code into a helper, thus into the view, this didn't feel much better either, as we had to check for the type of the model. That resulted in case statements which we do not speak about too much nowadays. Even bringing it up here caused me to cringe. <em>Polymorphism? Sadly, no.</em></p>
    <h2>The big question</h2>
    <p>So, where to put this view specific, model-type dependent code?</p>
    <h2>The solution</h2>
    <p>Enter view models, the public face of the normally shy models.</p>
    <h2>Repository</h2>
    <a href="http://github.com/floere/view_models">Check them out here</a>
  </body>
</html>